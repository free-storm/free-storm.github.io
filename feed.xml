<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>自由风暴</title>
  <subtitle>自由风暴</subtitle>
  <id>http://freestorm.org/</id>
  <link href="http://freestorm.org/"/>
  <link href="http://freestorm.org/feed.xml" rel="self"/>
  <updated>2015-04-21T16:00:00+00:00</updated>
  <author>
    <name>自由风暴</name>
  </author>
  <entry>
    <title>理解 CAP 理论</title>
    <link rel="alternate" href="/2015/04/22/理解CAP理论.html"/>
    <id>/2015/04/22/理解CAP理论.html</id>
    <published>2015-04-21T16:00:00+00:00</published>
    <updated>2015-04-21T16:00:00+00:00</updated>
    <author>
      <name>Michael Ding</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;strong&gt;CAP&lt;/strong&gt; 是分布式数据库中的重要理论之一。为了更好的理解分布式数据库，我们需要对 CAP 理论有个简单的理解。&lt;/p&gt;

&lt;h2&gt;1.CAP 概述&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;CAP&lt;/strong&gt; 证明了，对于一个分布式数据库系统，存在这样三个指标：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;strong&gt;C&lt;/strong&gt;&lt;em&gt;onsistent&lt;/em&gt;(写操作是 &lt;code&gt;原子&lt;/code&gt; 的，当写操作完成后，所有后续的读取操作获取得到的都必须是新值),&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;A&lt;/strong&gt;&lt;em&gt;vailable&lt;/em&gt;(只要还有一个节点服务器在运行，整个系统对于请求总是要返回结果)&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;P&lt;/strong&gt;&lt;em&gt;artition tolerant&lt;/em&gt;(当节点服务器之间的通信中断后，即：出现网络分区，整个系统还是能提供服务...&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;p&gt;&lt;strong&gt;CAP&lt;/strong&gt; 是分布式数据库中的重要理论之一。为了更好的理解分布式数据库，我们需要对 CAP 理论有个简单的理解。&lt;/p&gt;

&lt;h2&gt;1.CAP 概述&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;CAP&lt;/strong&gt; 证明了，对于一个分布式数据库系统，存在这样三个指标：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;C&lt;/strong&gt;&lt;em&gt;onsistent&lt;/em&gt;(写操作是 &lt;code&gt;原子&lt;/code&gt; 的，当写操作完成后，所有后续的读取操作获取得到的都必须是新值),&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A&lt;/strong&gt;&lt;em&gt;vailable&lt;/em&gt;(只要还有一个节点服务器在运行，整个系统对于请求总是要返回结果)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P&lt;/strong&gt;&lt;em&gt;artition tolerant&lt;/em&gt;(当节点服务器之间的通信中断后，即：出现网络分区，整个系统还是能提供服务的)。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而你只能在这三个指标中同时照顾好两个。&lt;/p&gt;

&lt;p&gt;根据 CAP 理论，当你在设计/使用分布式数据库时，你需要做出选择:在 Consistent, Available, Partition tolerant 中放弃什么。&lt;/p&gt;

&lt;p&gt;Partition tolerant 是个架构选择(数据库是否是分布式)，所以一般而言，你需要选择是更在意 Consistent 还是 Available。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;理解 CAP 理论对于做出正确的选择是至关重要的。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;2.CAP 小故事&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;为了更好地理解 CAP，这里以现实生活中的例子做个类比&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设这个世界是一个巨大的分布式系统，关于暴走漫画的知识是系统中存储的数据，暴漫的粉丝是这个分布式系统中的一个个节点。&lt;/p&gt;

&lt;p&gt;假设今天你刚刚看了最新一期暴走大事件(第三季43集)，而今天的日期是 &lt;code&gt;2015年4月18日&lt;/code&gt;，突然有一伙儿神秘人闯进你家门，把你抓到了深山里，让你参与建造方舟，并且与世隔绝。&lt;/p&gt;

&lt;p&gt;时光如梭，一转眼 5 年过去了，到了 &lt;code&gt;2020年1月2日&lt;/code&gt;。方舟建成，你被送回了家乡。在回家的路上，你遇到一个路人，问了你一个问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;暴走大事件最新一期是第几季第几集了？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这时候，你需要做一个选择：&lt;/p&gt;

&lt;p&gt;你可以回答你知道的最新一期(第三季43集，5年前的最新一期)。如果你选择回答，那你就是 &lt;code&gt;Available&lt;/code&gt; 的。或者你可以选择不回答，因为你已经与世隔绝 5 年，你知道你的答案很可能世界上其余暴漫粉丝的答案不一致(&lt;code&gt;Consistent&lt;/code&gt;)，这样这个路人得不到答案，但是整个世界是 &lt;code&gt;Consistent&lt;/code&gt; 的。&lt;/p&gt;

&lt;p&gt;即：你可以选择确保路人能得到答案(Available)，或者确保世界的一致性(Consistent)。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>配置自己的 docker-registry 服务</title>
    <link rel="alternate" href="/2015/04/20/setup-docker-registry.html"/>
    <id>/2015/04/20/setup-docker-registry.html</id>
    <published>2015-04-19T16:00:00+00:00</published>
    <updated>2015-04-19T16:00:00+00:00</updated>
    <author>
      <name>Michael Ding</name>
    </author>
    <summary type="html">&lt;p&gt;鉴于 docker 官网在国内的访问速度，在我们(暴走漫画)大量地将开发/部署环境迁移到 docker 以后，我们考虑自建 docker registry 服务。&lt;/p&gt;

&lt;p&gt;docker registry 的 github 地址是 &lt;a href="https://github.com/docker/docker-registry"&gt;https://github.com/docker/docker-registry&lt;/a&gt;。是一个基于 python 写的 web service.&lt;/p&gt;

&lt;p&gt;docker registry 最新的安装方式非常简单：&lt;code&gt;docker run -p 5000:5000 registry
&lt;/code&gt;。
...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;鉴于 docker 官网在国内的访问速度，在我们(暴走漫画)大量地将开发/部署环境迁移到 docker 以后，我们考虑自建 docker registry 服务。&lt;/p&gt;

&lt;p&gt;docker registry 的 github 地址是 &lt;a href="https://github.com/docker/docker-registry"&gt;https://github.com/docker/docker-registry&lt;/a&gt;。是一个基于 python 写的 web service.&lt;/p&gt;

&lt;p&gt;docker registry 最新的安装方式非常简单：&lt;code&gt;docker run -p 5000:5000 registry
&lt;/code&gt;。
其实也就是：docker registry 被制作成了 docker image，在要跑 docker registry 的服务器上装好 docker，
用 docker 去跑 docker registry 服务。&lt;/p&gt;

&lt;p&gt;因此我们可以利用 docker 的启动命令来启动符合自己需求的 registry 服务。&lt;/p&gt;

&lt;p&gt;主要有：&lt;/p&gt;

&lt;h3&gt;1. 利用环境变量修改配置&lt;/h3&gt;

&lt;p&gt;例如，你需要设置 search&lt;em&gt;backend，可以为 &lt;code&gt;docker run&lt;/code&gt; 增加参数：`-e SEARCH&lt;/em&gt;BACKEND=sqlalchemy`&lt;/p&gt;

&lt;p&gt;完整的环境变量对应的参数设置，可参见 &lt;a href="https://github.com/docker/docker-registry/blob/master/config/config_sample.yml"&gt;配置文件&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;另外，docker 的配置还有一个 &lt;a href="https://github.com/docker/docker-registry#configuration-flavors"&gt;Configuration flavors&lt;/a&gt;的概念。&lt;/p&gt;

&lt;p&gt;这个概念允许你定义一些&amp;quot;运行模式&amp;quot;，不同的模式采用不同的配置。例如&amp;quot;development&amp;quot;, &amp;ldquo;production&amp;quot;等等。&lt;/p&gt;

&lt;h3&gt;2. 利用自己的配置文件修改配置&lt;/h3&gt;

&lt;p&gt;你也可以编写自己的配置文件(参考 &lt;a href="https://github.com/docker/docker-registry/blob/master/config/config_sample.yml"&gt;默认配置文件&lt;/a&gt;),
然后利用 &lt;code&gt;docker run&lt;/code&gt; 的 &lt;code&gt;-v&lt;/code&gt; 参数，将自己的配置文件映射到 container 里面去，并设置相应的环境变量(&lt;code&gt;DOCKER_REGISTRY_CONFIG&lt;/code&gt;)，从而覆盖默认的配置。&lt;/p&gt;
&lt;pre&gt;&lt;code class="highlight plaintext"&gt;sudo docker run -p 5000:5000 -v /home/me/myfolder:/registry-conf -e DOCKER_REGISTRY_CONFIG=/registry-conf/mysuperconfig.yml registry
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3. 挂载数据卷&lt;/h3&gt;

&lt;p&gt;将 docker registry 存储 images 的路径映射出来是个明智的做法，这样即使重新创建 registry 的 container，也可以共用之前的 images&lt;/p&gt;

&lt;p&gt;可以利用 &lt;code&gt;docker run&lt;/code&gt; 的 &lt;code&gt;-v&lt;/code&gt; 参数，将一个宿主系统的配置文件映射到 container 里面，并设置响应的环境变量(&lt;code&gt;STORAGE_PATH&lt;/code&gt;)来实现。&lt;/p&gt;
&lt;pre&gt;&lt;code class="highlight plaintext"&gt;sudo docker run -p 5000:5000 -e STORAGE_PATH=/registry -v /data/docker-registry:/registry registry
&lt;/code&gt;&lt;/pre&gt;
</content>
  </entry>
  <entry>
    <title>Redis "Can't save in background: fork: Cannot allocate memory"</title>
    <link rel="alternate" href="/2015/03/15/Redis-Can-t-save-in-background-fork-Cannot-allocate-memory.html"/>
    <id>/2015/03/15/Redis-Can-t-save-in-background-fork-Cannot-allocate-memory.html</id>
    <published>2015-03-14T16:00:00+00:00</published>
    <updated>2015-03-14T16:00:00+00:00</updated>
    <author>
      <name>Michael Ding</name>
    </author>
    <summary type="html">&lt;h2&gt;问题&lt;/h2&gt;

&lt;p&gt;默认情况下，redis 的持久化方案是 RDB，对于数据丢失的风险相对较高。
如果对于持久化要求较高，一般会使用 AOF。&lt;/p&gt;

&lt;p&gt;不过使用 AOF 后，正常情况下，总会碰到 &lt;code&gt;Can’t save in background: fork: Cannot allocate memory&lt;/code&gt; 这样的错误。&lt;/p&gt;

&lt;p&gt;这个错误会出现的原因如下：&lt;/p&gt;

&lt;p&gt;Redis 的后台持久化基于操作系统 &lt;code&gt;fork&lt;/code&gt; 的 &lt;code&gt;copy-on-write&lt;/code&gt;特性。redis 会 fork 一个子进程，这个子进程是
父进程的完整拷贝。然后这...&lt;/p&gt;</summary>
    <content type="html">&lt;h2&gt;问题&lt;/h2&gt;

&lt;p&gt;默认情况下，redis 的持久化方案是 RDB，对于数据丢失的风险相对较高。
如果对于持久化要求较高，一般会使用 AOF。&lt;/p&gt;

&lt;p&gt;不过使用 AOF 后，正常情况下，总会碰到 &lt;code&gt;Can’t save in background: fork: Cannot allocate memory&lt;/code&gt; 这样的错误。&lt;/p&gt;

&lt;p&gt;这个错误会出现的原因如下：&lt;/p&gt;

&lt;p&gt;Redis 的后台持久化基于操作系统 &lt;code&gt;fork&lt;/code&gt; 的 &lt;code&gt;copy-on-write&lt;/code&gt;特性。redis 会 fork 一个子进程，这个子进程是
父进程的完整拷贝。然后这个子进程将数据库中的数据报存到磁盘上，完成后销毁。所以，理论上子进程需要消耗和父进程同样多的内存。
然而，由于 &lt;code&gt;copy-on-write&lt;/code&gt;，父子进程其实会共享内存区块。只有父进程中发生了变化的内存区块才会被真正拷贝。
由于理论上，所有的内存区块的数据都是有可能变化的，所以 Linux 并不能事先知道子进程到底真正要消耗多少内存。
所以如果 Linux 的内核参数 &lt;code&gt;overcommit_memory&lt;/code&gt; 设置成 &lt;code&gt;0&lt;/code&gt; 的话，除非空闲内存比父进程占用的内存还要多，
否则 &lt;code&gt;fork&lt;/code&gt; 就会失败。只有当 &lt;code&gt;overcommit_memory&lt;/code&gt; 被设置成 &lt;code&gt;1&lt;/code&gt;，Linux 才会尝试去 &lt;code&gt;fork&lt;/code&gt;。&lt;/p&gt;

&lt;h2&gt;方案&lt;/h2&gt;

&lt;p&gt;思路：将 &lt;code&gt;overcommit_memory&lt;/code&gt; 设置成 &lt;code&gt;1&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;方法 1&lt;/h4&gt;
&lt;pre&gt;&lt;code class="highlight plaintext"&gt;echo 1 &amp;gt; /proc/sys/vm/overcommit_memory
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;方法 2&lt;/h4&gt;
&lt;pre&gt;&lt;code class="highlight plaintext"&gt;sysctl vm.overcommit_memory=1
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;方法 3&lt;/h4&gt;
&lt;pre&gt;&lt;code class="highlight plaintext"&gt;echo 'vm.overcommit_memory=1' &amp;gt; /etc/sysctl.d/60-vm-memory.conf
service procps start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 60开头的文件中的设置会最晚被执行&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Shell 常用快捷键</title>
    <link rel="alternate" href="/2015/03/10/Shell常用快捷键.html"/>
    <id>/2015/03/10/Shell常用快捷键.html</id>
    <published>2015-03-09T16:00:00+00:00</published>
    <updated>2015-03-09T16:00:00+00:00</updated>
    <author>
      <name>Michael Ding</name>
    </author>
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Ctrl + a ：移到命令行首&lt;/li&gt;
&lt;li&gt;Ctrl + e ：移到命令行尾&lt;/li&gt;
&lt;li&gt;Ctrl + f ：-&amp;gt; (向右)&lt;/li&gt;
&lt;li&gt;Ctrl + b ：&amp;lt;- (向左)&lt;/li&gt;
&lt;li&gt;Ctrl + w ：从光标处删除至字首(删除一个单词)&lt;/li&gt;
&lt;li&gt;Ctrl + p：历史中的上一条命令 (向上)&lt;/li&gt;
&lt;li&gt;Ctrl + n：历史中的下一条命令 (向下)&lt;/li&gt;
&lt;li&gt;Ctrl + r：搜索命令历史 (重复按键以切换不同的搜索结果)&lt;/li&gt;
&lt;/ul&gt;
</summary>
    <content type="html">&lt;ul&gt;
&lt;li&gt;Ctrl + a ：移到命令行首&lt;/li&gt;
&lt;li&gt;Ctrl + e ：移到命令行尾&lt;/li&gt;
&lt;li&gt;Ctrl + f ：-&amp;gt; (向右)&lt;/li&gt;
&lt;li&gt;Ctrl + b ：&amp;lt;- (向左)&lt;/li&gt;
&lt;li&gt;Ctrl + w ：从光标处删除至字首(删除一个单词)&lt;/li&gt;
&lt;li&gt;Ctrl + p：历史中的上一条命令 (向上)&lt;/li&gt;
&lt;li&gt;Ctrl + n：历史中的下一条命令 (向下)&lt;/li&gt;
&lt;li&gt;Ctrl + r：搜索命令历史 (重复按键以切换不同的搜索结果)&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>利用 vagrant 构建开发环境</title>
    <link rel="alternate" href="/2015/02/27/利用vagrant构建开发环境.html"/>
    <id>/2015/02/27/利用vagrant构建开发环境.html</id>
    <published>2015-02-26T16:00:00+00:00</published>
    <updated>2015-02-26T16:00:00+00:00</updated>
    <author>
      <name>Michael Ding</name>
    </author>
    <summary type="html">&lt;h2&gt;Vagrant 简介&lt;/h2&gt;

&lt;p&gt;Vagrant 可以用来快速地搭建开发环境。&lt;/p&gt;

&lt;p&gt;Vagrant 可以看作是一个自动化地虚拟机管理程序。开发环境运行在虚拟机中，例如 &lt;a href="https://www.virtualbox.org/"&gt;virtualbox&lt;/a&gt;, &lt;a href="http://www.vmware.com/"&gt;vmware&lt;/a&gt; 等虚拟机。
可以将虚拟机的配置信息，包括：cpu，内存，网络，文件共享，初始化工作等等写在一个基于 Ruby 语法的配置文件中，
然后通过简单的 vagrant 命令即可以实现虚拟机的创建，开关机，睡眠唤醒，打包等等一系列操作。非常方便。&lt;/p&gt;

&lt;p&gt;如果时间允许，可以通过这个&lt;a href="http://happycasts.net/episodes/105"&gt;10分钟左右的视频&lt;/a&gt;来对 Vagrant...&lt;/p&gt;</summary>
    <content type="html">&lt;h2&gt;Vagrant 简介&lt;/h2&gt;

&lt;p&gt;Vagrant 可以用来快速地搭建开发环境。&lt;/p&gt;

&lt;p&gt;Vagrant 可以看作是一个自动化地虚拟机管理程序。开发环境运行在虚拟机中，例如 &lt;a href="https://www.virtualbox.org/"&gt;virtualbox&lt;/a&gt;, &lt;a href="http://www.vmware.com/"&gt;vmware&lt;/a&gt; 等虚拟机。
可以将虚拟机的配置信息，包括：cpu，内存，网络，文件共享，初始化工作等等写在一个基于 Ruby 语法的配置文件中，
然后通过简单的 vagrant 命令即可以实现虚拟机的创建，开关机，睡眠唤醒，打包等等一系列操作。非常方便。&lt;/p&gt;

&lt;p&gt;如果时间允许，可以通过这个&lt;a href="http://happycasts.net/episodes/105"&gt;10分钟左右的视频&lt;/a&gt;来对 Vagrant 有个更直观的了解。&lt;/p&gt;

&lt;h2&gt;制作 base box&lt;/h2&gt;

&lt;h4&gt;为什么要制作 base box?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;base box 顾名思义，是一个虚拟机(开发环境)起点、基础。可以将一些初始化工作(例如安装特定软件)做到base box 里，这样这些初始化工作就可以省略了。&lt;/li&gt;
&lt;li&gt;虽然很多初始化工作可以写在 vagrant 的配置文件里，然而由于国内网速的问题，有很多需要下载的工作(例如docker pull image)时，初始化过程会太过不确定和缓慢。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;制作步骤&lt;/h4&gt;

&lt;h6&gt;登录进一个要作为base box 模板的 vagrant 实例&lt;/h6&gt;
&lt;pre&gt;&lt;code class="highlight plaintext"&gt;cd /path/to/vagrant
vagrant up
vagrant ssh
&lt;/code&gt;&lt;/pre&gt;

&lt;h6&gt;设置 insecure public key&lt;/h6&gt;
&lt;pre&gt;&lt;code class="highlight plaintext"&gt;curl https://raw.githubusercontent.com/mitchellh/vagrant/master/keys/vagrant.pub &amp;gt; .ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;

&lt;h6&gt;清理 box&lt;/h6&gt;
&lt;pre&gt;&lt;code class="highlight plaintext"&gt;sudo dd if=/dev/zero of=/EMPTY bs=1M
sudo rm -f /EMPTY
cat /dev/null &amp;gt; ~/.bash_history &amp;amp;&amp;amp; history -c &amp;amp;&amp;amp; exit
&lt;/code&gt;&lt;/pre&gt;

&lt;h6&gt;打包 box&lt;/h6&gt;
&lt;pre&gt;&lt;code class="highlight plaintext"&gt;vagrant package --output /path/to/dev.box
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;使用 base box&lt;/h4&gt;
&lt;pre&gt;&lt;code class="highlight plaintext"&gt;vagrant box add dev /path/to/dev.box
vagrant init dev
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.vagrantup.com/"&gt;Vagrant 官方网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://docs.vagrantup.com/v2/boxes/base.html"&gt;Vagrant base box 制作&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
</feed>
