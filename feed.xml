<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>自由风暴</title>
  <subtitle>自由风暴</subtitle>
  <id>http://freestorm.org/</id>
  <link href="http://freestorm.org/"/>
  <link href="http://freestorm.org/feed.xml" rel="self"/>
  <updated>2015-03-14T16:00:00+00:00</updated>
  <author>
    <name>自由风暴</name>
  </author>
  <entry>
    <title>Redis "Can't save in background: fork: Cannot allocate memory"</title>
    <link rel="alternate" href="/2015/03/15/Redis-Can-t-save-in-background-fork-Cannot-allocate-memory.html"/>
    <id>/2015/03/15/Redis-Can-t-save-in-background-fork-Cannot-allocate-memory.html</id>
    <published>2015-03-14T16:00:00+00:00</published>
    <updated>2015-03-14T16:00:00+00:00</updated>
    <author>
      <name>Michael Ding</name>
    </author>
    <summary type="html">&lt;h2&gt;问题&lt;/h2&gt;

&lt;p&gt;默认情况下，redis 的持久化方案是 RDB，对于数据丢失的风险相对较高。
如果对于持久化要求较高，一般会使用 AOF。&lt;/p&gt;

&lt;p&gt;不过使用 AOF 后，正常情况下，总会碰到 &lt;code&gt;Can’t save in background: fork: Cannot allocate memory&lt;/code&gt; 这样的错误。&lt;/p&gt;

&lt;p&gt;这个错误会出现的原因如下：&lt;/p&gt;

&lt;p&gt;Redis 的后台持久化基于操作系统 &lt;code&gt;fork&lt;/code&gt; 的 &lt;code&gt;copy-on-write&lt;/code&gt;特性。redis 会 fork 一个子进程，这个子进程是
父进程的完整拷贝。然后这...&lt;/p&gt;</summary>
    <content type="html">&lt;h2&gt;问题&lt;/h2&gt;

&lt;p&gt;默认情况下，redis 的持久化方案是 RDB，对于数据丢失的风险相对较高。
如果对于持久化要求较高，一般会使用 AOF。&lt;/p&gt;

&lt;p&gt;不过使用 AOF 后，正常情况下，总会碰到 &lt;code&gt;Can’t save in background: fork: Cannot allocate memory&lt;/code&gt; 这样的错误。&lt;/p&gt;

&lt;p&gt;这个错误会出现的原因如下：&lt;/p&gt;

&lt;p&gt;Redis 的后台持久化基于操作系统 &lt;code&gt;fork&lt;/code&gt; 的 &lt;code&gt;copy-on-write&lt;/code&gt;特性。redis 会 fork 一个子进程，这个子进程是
父进程的完整拷贝。然后这个子进程将数据库中的数据报存到磁盘上，完成后销毁。所以，理论上子进程需要消耗和父进程同样多的内存。
然而，由于 &lt;code&gt;copy-on-write&lt;/code&gt;，父子进程其实会共享内存区块。只有父进程中发生了变化的内存区块才会被真正拷贝。
由于理论上，所有的内存区块的数据都是有可能变化的，所以 Linux 并不能事先知道子进程到底真正要消耗多少内存。
所以如果 Linux 的内核参数 &lt;code&gt;overcommit_memory&lt;/code&gt; 设置成 &lt;code&gt;0&lt;/code&gt; 的话，除非空闲内存比父进程占用的内存还要多，
否则 &lt;code&gt;fork&lt;/code&gt; 就会失败。只有当 &lt;code&gt;overcommit_memory&lt;/code&gt; 被设置成 &lt;code&gt;1&lt;/code&gt;，Linux 才会尝试去 &lt;code&gt;fork&lt;/code&gt;。&lt;/p&gt;

&lt;h2&gt;方案&lt;/h2&gt;

&lt;p&gt;思路：将 &lt;code&gt;overcommit_memory&lt;/code&gt; 设置成 &lt;code&gt;1&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;方法 1&lt;/h4&gt;
&lt;pre&gt;&lt;code class="highlight plaintext"&gt;echo 1 &amp;gt; /proc/sys/vm/overcommit_memory
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;方法 2&lt;/h4&gt;
&lt;pre&gt;&lt;code class="highlight plaintext"&gt;sysctl vm.overcommit_memory=1
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;方法 3&lt;/h4&gt;
&lt;pre&gt;&lt;code class="highlight plaintext"&gt;echo 'vm.overcommit_memory=1' &amp;gt; /etc/sysctl.d/60-vm-memory.conf
service procps start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 60开头的文件中的设置会最晚被执行&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Shell 常用快捷键</title>
    <link rel="alternate" href="/2015/03/10/Shell常用快捷键.html"/>
    <id>/2015/03/10/Shell常用快捷键.html</id>
    <published>2015-03-09T16:00:00+00:00</published>
    <updated>2015-03-09T16:00:00+00:00</updated>
    <author>
      <name>Michael Ding</name>
    </author>
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Ctrl + a ：移到命令行首&lt;/li&gt;
&lt;li&gt;Ctrl + e ：移到命令行尾&lt;/li&gt;
&lt;li&gt;Ctrl + f ：-&amp;gt; (向右)&lt;/li&gt;
&lt;li&gt;Ctrl + b ：&amp;lt;- (向左)&lt;/li&gt;
&lt;li&gt;Ctrl + w ：从光标处删除至字首(删除一个单词)&lt;/li&gt;
&lt;li&gt;Ctrl + p：历史中的上一条命令 (向上)&lt;/li&gt;
&lt;li&gt;Ctrl + n：历史中的下一条命令 (向下)&lt;/li&gt;
&lt;li&gt;Ctrl + r：搜索命令历史 (重复按键以切换不同的搜索结果)&lt;/li&gt;
&lt;/ul&gt;
</summary>
    <content type="html">&lt;ul&gt;
&lt;li&gt;Ctrl + a ：移到命令行首&lt;/li&gt;
&lt;li&gt;Ctrl + e ：移到命令行尾&lt;/li&gt;
&lt;li&gt;Ctrl + f ：-&amp;gt; (向右)&lt;/li&gt;
&lt;li&gt;Ctrl + b ：&amp;lt;- (向左)&lt;/li&gt;
&lt;li&gt;Ctrl + w ：从光标处删除至字首(删除一个单词)&lt;/li&gt;
&lt;li&gt;Ctrl + p：历史中的上一条命令 (向上)&lt;/li&gt;
&lt;li&gt;Ctrl + n：历史中的下一条命令 (向下)&lt;/li&gt;
&lt;li&gt;Ctrl + r：搜索命令历史 (重复按键以切换不同的搜索结果)&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>利用 vagrant 构建开发环境</title>
    <link rel="alternate" href="/2015/02/27/利用vagrant构建开发环境.html"/>
    <id>/2015/02/27/利用vagrant构建开发环境.html</id>
    <published>2015-02-26T16:00:00+00:00</published>
    <updated>2015-02-26T16:00:00+00:00</updated>
    <author>
      <name>Michael Ding</name>
    </author>
    <summary type="html">&lt;h2&gt;Vagrant 简介&lt;/h2&gt;

&lt;p&gt;Vagrant 可以用来快速地搭建开发环境。&lt;/p&gt;

&lt;p&gt;Vagrant 可以看作是一个自动化地虚拟机管理程序。开发环境运行在虚拟机中，例如 &lt;a href="https://www.virtualbox.org/"&gt;virtualbox&lt;/a&gt;, &lt;a href="http://www.vmware.com/"&gt;vmware&lt;/a&gt; 等虚拟机。
可以将虚拟机的配置信息，包括：cpu，内存，网络，文件共享，初始化工作等等写在一个基于 Ruby 语法的配置文件中，
然后通过简单的 vagrant 命令即可以实现虚拟机的创建，开关机，睡眠唤醒，打包等等一系列操作。非常方便。&lt;/p&gt;

&lt;p&gt;如果时间允许，可以通过这个&lt;a href="http://happycasts.net/episodes/105"&gt;10分钟左右的视频&lt;/a&gt;来对 Vagrant...&lt;/p&gt;</summary>
    <content type="html">&lt;h2&gt;Vagrant 简介&lt;/h2&gt;

&lt;p&gt;Vagrant 可以用来快速地搭建开发环境。&lt;/p&gt;

&lt;p&gt;Vagrant 可以看作是一个自动化地虚拟机管理程序。开发环境运行在虚拟机中，例如 &lt;a href="https://www.virtualbox.org/"&gt;virtualbox&lt;/a&gt;, &lt;a href="http://www.vmware.com/"&gt;vmware&lt;/a&gt; 等虚拟机。
可以将虚拟机的配置信息，包括：cpu，内存，网络，文件共享，初始化工作等等写在一个基于 Ruby 语法的配置文件中，
然后通过简单的 vagrant 命令即可以实现虚拟机的创建，开关机，睡眠唤醒，打包等等一系列操作。非常方便。&lt;/p&gt;

&lt;p&gt;如果时间允许，可以通过这个&lt;a href="http://happycasts.net/episodes/105"&gt;10分钟左右的视频&lt;/a&gt;来对 Vagrant 有个更直观的了解。&lt;/p&gt;

&lt;h2&gt;制作 base box&lt;/h2&gt;

&lt;h4&gt;为什么要制作 base box?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;base box 顾名思义，是一个虚拟机(开发环境)起点、基础。可以将一些初始化工作(例如安装特定软件)做到base box 里，这样这些初始化工作就可以省略了。&lt;/li&gt;
&lt;li&gt;虽然很多初始化工作可以写在 vagrant 的配置文件里，然而由于国内网速的问题，有很多需要下载的工作(例如docker pull image)时，初始化过程会太过不确定和缓慢。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;制作步骤&lt;/h4&gt;

&lt;h6&gt;登录进一个要作为base box 模板的 vagrant 实例&lt;/h6&gt;
&lt;pre&gt;&lt;code class="highlight plaintext"&gt;cd /path/to/vagrant
vagrant up
vagrant ssh
&lt;/code&gt;&lt;/pre&gt;

&lt;h6&gt;设置 insecure public key&lt;/h6&gt;
&lt;pre&gt;&lt;code class="highlight plaintext"&gt;curl https://raw.githubusercontent.com/mitchellh/vagrant/master/keys/vagrant.pub &amp;gt; .ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;

&lt;h6&gt;清理 box&lt;/h6&gt;
&lt;pre&gt;&lt;code class="highlight plaintext"&gt;sudo dd if=/dev/zero of=/EMPTY bs=1M
sudo rm -f /EMPTY
cat /dev/null &amp;gt; ~/.bash_history &amp;amp;&amp;amp; history -c &amp;amp;&amp;amp; exit
&lt;/code&gt;&lt;/pre&gt;

&lt;h6&gt;打包 box&lt;/h6&gt;
&lt;pre&gt;&lt;code class="highlight plaintext"&gt;vagrant package --output /path/to/dev.box
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;使用 base box&lt;/h4&gt;
&lt;pre&gt;&lt;code class="highlight plaintext"&gt;vagrant box add dev /path/to/dev.box
vagrant init dev
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.vagrantup.com/"&gt;Vagrant 官方网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://docs.vagrantup.com/v2/boxes/base.html"&gt;Vagrant base box 制作&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
</feed>
