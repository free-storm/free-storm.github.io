<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>自由风暴</title>
  <subtitle>自由风暴</subtitle>
  <id>http://freestorm.org/</id>
  <link href="http://freestorm.org/"/>
  <link href="http://freestorm.org/feed.xml" rel="self"/>
  <updated>2015-04-24T16:00:00+00:00</updated>
  <author>
    <name>自由风暴</name>
  </author>
  <entry>
    <title>Riak 的分布式数据库模型 - 分布式数据库相关理论 Part 3</title>
    <link rel="alternate" href="/2015/04/25/Riak的分布式数据库模型.html"/>
    <id>/2015/04/25/Riak的分布式数据库模型.html</id>
    <published>2015-04-24T16:00:00+00:00</published>
    <updated>2015-04-24T16:00:00+00:00</updated>
    <author>
      <name>Michael Ding</name>
    </author>
    <summary type="html">&lt;h2&gt;Riak 是什么&lt;/h2&gt;

&lt;p&gt;Riak 是一个 erlang 开发的开源的分布式 key-value 数据库，
在 &lt;code&gt;High Availability&lt;/code&gt;, &lt;code&gt;Fault Tolerance&lt;/code&gt;, &lt;code&gt;Scalability&lt;/code&gt; 方面表现优异。
其实现受  &lt;a href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf"&gt;Amazon Dynamodb&lt;/a&gt; 启发，是一个很有代表性的分布式数据库。&lt;/p&gt;

&lt;p&gt;Riak 集群是一个去中心化的集群。每个服务器节点都是平等的，可以自由地添加和删除。
这使得 Riak 的故障转移(Failure Over)和扩展非常容易。
在 CAP 理论方面，Riak...&lt;/p&gt;</summary>
    <content type="html">&lt;h2&gt;Riak 是什么&lt;/h2&gt;

&lt;p&gt;Riak 是一个 erlang 开发的开源的分布式 key-value 数据库，
在 &lt;code&gt;High Availability&lt;/code&gt;, &lt;code&gt;Fault Tolerance&lt;/code&gt;, &lt;code&gt;Scalability&lt;/code&gt; 方面表现优异。
其实现受  &lt;a href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf"&gt;Amazon Dynamodb&lt;/a&gt; 启发，是一个很有代表性的分布式数据库。&lt;/p&gt;

&lt;p&gt;Riak 集群是一个去中心化的集群。每个服务器节点都是平等的，可以自由地添加和删除。
这使得 Riak 的故障转移(Failure Over)和扩展非常容易。
在 CAP 理论方面，Riak 可以自由地在 CP 和 AP 之间做平衡。&lt;/p&gt;

&lt;h2&gt;理解 Riak 的分布式数据库模型&lt;/h2&gt;

&lt;h3&gt;Riak 的数据冗余&lt;/h3&gt;

&lt;p&gt;下面还是让我们从简单的例子开始，来理解下 Riak 的分布式数据库模型，包括数据的存储，节点服务器的，CAP理论的关系等。&lt;/p&gt;

&lt;p&gt;首先让我们先定义一个概念：&lt;code&gt;N&lt;/code&gt;，表示数据的&amp;quot;份数&amp;quot;。在分布式数据库中，一份数据往往会存储多份拷贝(所谓冗余，或者 replications)&lt;/p&gt;

&lt;p&gt;现在，假设我们有一个服务器节点(node1)，存有三个数据(key分别是 P0, P1, P2)，N = 1。那么可以想象，这三个数据都是存放在 node1 中。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img alt="fig1" src="/images/1-node-with-3-data-e7c30ed4.png" /&gt;&lt;/p&gt;

&lt;p&gt;当 N = 2 时，假设 P0, P1, P2 的冗余数据分别是 R0, R1, R2， 那么可以想象，这6个数据也应该都存储在 node1 中，如 下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img alt="fig2" src="/images/1-node-with-3x2-data-90719dca.png" /&gt;&lt;/p&gt;

&lt;p&gt;这时候，让我们把服务器节点增加到2个(node1, node2)，那么可以想象，6个数据有很多中组合方式，例如下面这两种：&lt;/p&gt;

&lt;p&gt;&lt;img alt="fig3" src="/images/2-node-with-3x2-data-1-3864a6bb.png" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt="fig4" src="/images/2-node-with-3x2-data-2-758f4a81.png" /&gt;&lt;/p&gt;

&lt;p&gt;也许你发现了，他们有个共同点：&lt;strong&gt;同一个数据的冗余数据放在不同的服务器节点中&lt;/strong&gt;。这样就算一个节点删除(当机)了，集群的数据仍然能保证完整性。
这为故障转移(Failure over)提供了基础。&lt;/p&gt;

&lt;p&gt;那么现在的问题来了，&lt;strong&gt;是否有什么科学(公式化)的方式来找到分配这些数据的组合(之一)呢&lt;/strong&gt;？&lt;/p&gt;

&lt;h3&gt;Riak Ring&lt;/h3&gt;

&lt;p&gt;Riak 通过被称作 &lt;code&gt;Riak Ring&lt;/code&gt; 的东西来解决这个问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;首先&lt;/strong&gt;，Riak 将所有的 key 通过 hash 函数映射到一个 160 bit 的整数空间中。
即一个 key 对应着一个 0 ~ 2^160 - 1 的整数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;然后&lt;/strong&gt;，Riak 引入了 vnode(虚拟节点) 的概念，vnode 个数是可以配置的，默认是 64。
160 bit 的整数会均匀的分布到所有的 vnode。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;最后&lt;/strong&gt;，这些 vnode 会&amp;quot;均匀地&amp;quot;分配到 物理节点上。具体的分配的方法很巧妙，通过 &lt;code&gt;Riak Ring&lt;/code&gt; 这样的东西。&lt;/p&gt;

&lt;p&gt;下面我们用一幅图来具体解释下 &lt;code&gt;Riak Ring&lt;/code&gt;。图中，假设 vnode 32 个，服务器节点 4个。&lt;/p&gt;

&lt;p&gt;&lt;img alt="fig5" src="/images/riak-ring-99006345.png" /&gt;&lt;/p&gt;

&lt;p&gt;让我们把 160 bit 想像成一个环，环上的一小段代表一个 vnode。四种颜色分别代表 4 个服务器节点。&lt;/p&gt;

&lt;p&gt;2^160 个整数按照从小到大的顺序均匀地分布到 32 个 vnode 中，例如 2^159 是第 17 个 vnode 上的第一个整数。&lt;/p&gt;

&lt;p&gt;32 个 vnode 按照从小到大的顺序依次被分配到 4 个服务器节点上。即：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1, 5, 9&amp;hellip;29 vnode 分配给第1个服务器节点(node1)&lt;/li&gt;
&lt;li&gt;2, 6, 10&amp;hellip;30 vnode 分配给第1个服务器节点(node2)&lt;/li&gt;
&lt;li&gt;3, 7, 11&amp;hellip;31 vnode 分配给第1个服务器节点(node3)&lt;/li&gt;
&lt;li&gt;4, 8, 12&amp;hellip;32 vnode 分配给第1个服务器节点(node4)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;现在还剩下一个问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;冗余数据的存储&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们先假设 N = 3(即有2份冗余存储)&lt;/p&gt;

&lt;p&gt;假设要存储的数据，key 为 &lt;code&gt;test-key&lt;/code&gt; ，根据 Riak Ring 算出来，应该存储在 vnode6(即：node2)上。
那么 拷贝1 存储在 vnode7(即：node3)上，拷贝2 存储在 vnode8(即：node4)上。&lt;/p&gt;

&lt;p&gt;所以 Riak 对于冗余数据的存储策略是：&lt;strong&gt;将冗余数据依次存到下一个vnode中&lt;/strong&gt;。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Eventual Consistency(最终一致性) - 分布式数据库相关理论 Part 2</title>
    <link rel="alternate" href="/2015/04/23/Eventual-Consistency(最终一致性).html"/>
    <id>/2015/04/23/Eventual-Consistency(最终一致性).html</id>
    <published>2015-04-22T16:00:00+00:00</published>
    <updated>2015-04-22T16:00:00+00:00</updated>
    <author>
      <name>Michael Ding</name>
    </author>
    <summary type="html">&lt;h2&gt;1. Eventual Consistency 概述&lt;/h2&gt;

&lt;p&gt;分布式数据库必须要有 &lt;code&gt;分区容忍性(Partition Tolerant)&lt;/code&gt;，所以主要是在 &lt;code&gt;一致性(Consistent)&lt;/code&gt; 和 &lt;code&gt;可用性(Available)&lt;/code&gt; 之间做选择。
虽然在 CAP 理论中，选择了 &lt;code&gt;Availability&lt;/code&gt; 就不可能得到真正的 &lt;code&gt;Consistency&lt;/code&gt;，但是你可以追求 &lt;code&gt;最终一致性(Evental Consistency)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;evental Consistency&lt;/code&gt; 背后的思路是：每个系统节点总是 &lt;code&gt;Available&lt;/code&gt; 的，...&lt;/p&gt;</summary>
    <content type="html">&lt;h2&gt;1. Eventual Consistency 概述&lt;/h2&gt;

&lt;p&gt;分布式数据库必须要有 &lt;code&gt;分区容忍性(Partition Tolerant)&lt;/code&gt;，所以主要是在 &lt;code&gt;一致性(Consistent)&lt;/code&gt; 和 &lt;code&gt;可用性(Available)&lt;/code&gt; 之间做选择。
虽然在 CAP 理论中，选择了 &lt;code&gt;Availability&lt;/code&gt; 就不可能得到真正的 &lt;code&gt;Consistency&lt;/code&gt;，但是你可以追求 &lt;code&gt;最终一致性(Evental Consistency)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;evental Consistency&lt;/code&gt; 背后的思路是：每个系统节点总是 &lt;code&gt;Available&lt;/code&gt; 的，同时任何的写(修改数据)操作都会在后台同步给系统的其他节点。
这意味着，在任意时刻，整个系统是&lt;code&gt;Inconsistent(不一致的)&lt;/code&gt;，然而从概率上讲，大多数的请求得到的值是准确的。&lt;/p&gt;

&lt;p&gt;互联网的 DNS(域名服务) 就是最终一致性的一个非常好的例子。你注册了一个域名，
这个新域名需要几天的时间才能通知给所有的 DNS 服务器。但是不管什么时候，你能够连接到的任意 DNS 服务器对你来说都是 &amp;lsquo;Available&amp;rsquo; 的。&lt;/p&gt;

&lt;h2&gt;2. Eventual Consistency 小故事&lt;/h2&gt;

&lt;p&gt;让我们接着之前的&lt;a href="/2015/04/22/理解CAP理论.html"&gt;小故事&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;假设你不是深山里，是被抓到一个孤岛上造方舟。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;2015年7月3日&lt;/code&gt;——距离你被抓来造方舟已经将近3个月，你在孤岛的海边捡到了一个漂流瓶，里面写着：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;最新一期暴走大事件是第四季第2期&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以你知道：最新一期暴走大事件至少是&lt;code&gt;第四季第2期&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;假设暴漫的粉丝喜欢玩漂流瓶——只要暴走大事件有更新，就会把最新一期的暴走大事件写在纸上，然后通过漂流瓶扔向大海。
这样，像你这样的被 &lt;code&gt;Partition&lt;/code&gt; 的人，总是能时不时地收到记录着最新一期暴走大事件是什么的漂流瓶。
换句话说，虽然每一时刻，关于“最新一期暴走大事件是什么”你并不一定知道的是正确的答案，但你总是会 &lt;code&gt;eventually(最终)&lt;/code&gt; 知道正确答案。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>理解 CAP 理论  - 分布式数据库相关理论 Part 1</title>
    <link rel="alternate" href="/2015/04/22/理解CAP理论.html"/>
    <id>/2015/04/22/理解CAP理论.html</id>
    <published>2015-04-21T16:00:00+00:00</published>
    <updated>2015-04-21T16:00:00+00:00</updated>
    <author>
      <name>Michael Ding</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;strong&gt;CAP&lt;/strong&gt; 是分布式数据库中的重要理论之一。为了更好的理解分布式数据库，我们需要对 CAP 理论有个简单的理解。&lt;/p&gt;

&lt;h2&gt;1.CAP 概述&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;CAP&lt;/strong&gt; 证明了，对于一个分布式数据库系统，存在这样三个指标：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;strong&gt;C&lt;/strong&gt;&lt;em&gt;onsistent&lt;/em&gt;(一致性。写操作是 &lt;code&gt;原子&lt;/code&gt; 的，当写操作完成后，所有后续的读取操作获取得到的都必须是新值),&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;A&lt;/strong&gt;&lt;em&gt;vailable&lt;/em&gt;(可用性。只要还有一个节点服务器在运行，整个系统对于请求总是要返回结果)&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;P&lt;/strong&gt;&lt;em&gt;artition tolerant&lt;/em&gt;(分区容忍性。当节点服务器之间的通信中断后，即：出现网络...&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;p&gt;&lt;strong&gt;CAP&lt;/strong&gt; 是分布式数据库中的重要理论之一。为了更好的理解分布式数据库，我们需要对 CAP 理论有个简单的理解。&lt;/p&gt;

&lt;h2&gt;1.CAP 概述&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;CAP&lt;/strong&gt; 证明了，对于一个分布式数据库系统，存在这样三个指标：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;C&lt;/strong&gt;&lt;em&gt;onsistent&lt;/em&gt;(一致性。写操作是 &lt;code&gt;原子&lt;/code&gt; 的，当写操作完成后，所有后续的读取操作获取得到的都必须是新值),&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A&lt;/strong&gt;&lt;em&gt;vailable&lt;/em&gt;(可用性。只要还有一个节点服务器在运行，整个系统对于请求总是要返回结果)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P&lt;/strong&gt;&lt;em&gt;artition tolerant&lt;/em&gt;(分区容忍性。当节点服务器之间的通信中断后，即：出现网络分区，整个系统还是能提供服务的)。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而你只能在这三个指标中同时照顾好两个。&lt;/p&gt;

&lt;p&gt;根据 CAP 理论，当你在设计/使用分布式数据库时，你需要做出选择:在 Consistent, Available, Partition tolerant 中放弃什么。&lt;/p&gt;

&lt;p&gt;Partition tolerant 是个架构选择(数据库是否是分布式)，所以一般而言，你需要选择是更在意 Consistent 还是 Available。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;理解 CAP 理论对于做出正确的选择是至关重要的。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;2.CAP 小故事&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;为了更好地理解 CAP，这里以现实生活中的例子做个类比&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设这个世界是一个巨大的分布式系统，关于暴走漫画的知识是系统中存储的数据，暴漫的粉丝是这个分布式系统中的一个个节点。&lt;/p&gt;

&lt;p&gt;假设今天你刚刚看了最新一期暴走大事件(第三季43集)，而今天的日期是 &lt;code&gt;2015年4月18日&lt;/code&gt;，突然有一伙儿神秘人闯进你家门，把你抓到了深山里，让你参与建造方舟，并且与世隔绝。&lt;/p&gt;

&lt;p&gt;时光如梭，一转眼 5 年过去了，到了 &lt;code&gt;2020年1月2日&lt;/code&gt;。方舟建成，你被送回了家乡。在回家的路上，你遇到一个路人，问了你一个问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;暴走大事件最新一期是第几季第几集了？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这时候，你需要做一个选择：&lt;/p&gt;

&lt;p&gt;你可以回答你知道的最新一期(第三季43集，5年前的最新一期)。如果你选择回答，那你就是 &lt;code&gt;Available&lt;/code&gt; 的。或者你可以选择不回答，因为你已经与世隔绝了 5  年，你知道你的答案很可能和世界上其余暴漫粉丝的答案不一致(&lt;code&gt;Consistent&lt;/code&gt;)，这样这个路人得不到答案，但是整个世界是 &lt;code&gt;Consistent&lt;/code&gt; 的。&lt;/p&gt;

&lt;p&gt;即：你可以选择确保路人能得到答案(Available)，或者确保世界的一致性(Consistent)。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>配置自己的 docker-registry 服务</title>
    <link rel="alternate" href="/2015/04/20/setup-docker-registry.html"/>
    <id>/2015/04/20/setup-docker-registry.html</id>
    <published>2015-04-19T16:00:00+00:00</published>
    <updated>2015-04-19T16:00:00+00:00</updated>
    <author>
      <name>Michael Ding</name>
    </author>
    <summary type="html">&lt;p&gt;鉴于 docker 官网在国内的访问速度，在我们(暴走漫画)大量地将开发/部署环境迁移到 docker 以后，我们考虑自建 docker registry 服务。&lt;/p&gt;

&lt;p&gt;docker registry 的 github 地址是 &lt;a href="https://github.com/docker/docker-registry"&gt;https://github.com/docker/docker-registry&lt;/a&gt;。是一个基于 python 写的 web service.&lt;/p&gt;

&lt;p&gt;docker registry 最新的安装方式非常简单：&lt;code&gt;docker run -p 5000:5000 registry
&lt;/code&gt;。
...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;鉴于 docker 官网在国内的访问速度，在我们(暴走漫画)大量地将开发/部署环境迁移到 docker 以后，我们考虑自建 docker registry 服务。&lt;/p&gt;

&lt;p&gt;docker registry 的 github 地址是 &lt;a href="https://github.com/docker/docker-registry"&gt;https://github.com/docker/docker-registry&lt;/a&gt;。是一个基于 python 写的 web service.&lt;/p&gt;

&lt;p&gt;docker registry 最新的安装方式非常简单：&lt;code&gt;docker run -p 5000:5000 registry
&lt;/code&gt;。
其实也就是：docker registry 被制作成了 docker image，在要跑 docker registry 的服务器上装好 docker，
用 docker 去跑 docker registry 服务。&lt;/p&gt;

&lt;p&gt;因此我们可以利用 docker 的启动命令来启动符合自己需求的 registry 服务。&lt;/p&gt;

&lt;p&gt;主要有：&lt;/p&gt;

&lt;h3&gt;1. 利用环境变量修改配置&lt;/h3&gt;

&lt;p&gt;例如，你需要设置 search&lt;em&gt;backend，可以为 &lt;code&gt;docker run&lt;/code&gt; 增加参数：`-e SEARCH&lt;/em&gt;BACKEND=sqlalchemy`&lt;/p&gt;

&lt;p&gt;完整的环境变量对应的参数设置，可参见 &lt;a href="https://github.com/docker/docker-registry/blob/master/config/config_sample.yml"&gt;配置文件&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;另外，docker 的配置还有一个 &lt;a href="https://github.com/docker/docker-registry#configuration-flavors"&gt;Configuration flavors&lt;/a&gt;的概念。&lt;/p&gt;

&lt;p&gt;这个概念允许你定义一些&amp;quot;运行模式&amp;quot;，不同的模式采用不同的配置。例如&amp;quot;development&amp;quot;, &amp;ldquo;production&amp;quot;等等。&lt;/p&gt;

&lt;h3&gt;2. 利用自己的配置文件修改配置&lt;/h3&gt;

&lt;p&gt;你也可以编写自己的配置文件(参考 &lt;a href="https://github.com/docker/docker-registry/blob/master/config/config_sample.yml"&gt;默认配置文件&lt;/a&gt;),
然后利用 &lt;code&gt;docker run&lt;/code&gt; 的 &lt;code&gt;-v&lt;/code&gt; 参数，将自己的配置文件映射到 container 里面去，并设置相应的环境变量(&lt;code&gt;DOCKER_REGISTRY_CONFIG&lt;/code&gt;)，从而覆盖默认的配置。&lt;/p&gt;
&lt;pre&gt;&lt;code class="highlight plaintext"&gt;sudo docker run -p 5000:5000 -v /home/me/myfolder:/registry-conf -e DOCKER_REGISTRY_CONFIG=/registry-conf/mysuperconfig.yml registry
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3. 挂载数据卷&lt;/h3&gt;

&lt;p&gt;将 docker registry 存储 images 的路径映射出来是个明智的做法，这样即使重新创建 registry 的 container，也可以共用之前的 images&lt;/p&gt;

&lt;p&gt;可以利用 &lt;code&gt;docker run&lt;/code&gt; 的 &lt;code&gt;-v&lt;/code&gt; 参数，将一个宿主系统的配置文件映射到 container 里面，并设置响应的环境变量(&lt;code&gt;STORAGE_PATH&lt;/code&gt;)来实现。&lt;/p&gt;
&lt;pre&gt;&lt;code class="highlight plaintext"&gt;sudo docker run -p 5000:5000 -e STORAGE_PATH=/registry -v /data/docker-registry:/registry registry
&lt;/code&gt;&lt;/pre&gt;
</content>
  </entry>
  <entry>
    <title>Redis "Can't save in background: fork: Cannot allocate memory"</title>
    <link rel="alternate" href="/2015/03/15/Redis-Can-t-save-in-background-fork-Cannot-allocate-memory.html"/>
    <id>/2015/03/15/Redis-Can-t-save-in-background-fork-Cannot-allocate-memory.html</id>
    <published>2015-03-14T16:00:00+00:00</published>
    <updated>2015-03-14T16:00:00+00:00</updated>
    <author>
      <name>Michael Ding</name>
    </author>
    <summary type="html">&lt;h2&gt;问题&lt;/h2&gt;

&lt;p&gt;默认情况下，redis 的持久化方案是 RDB，对于数据丢失的风险相对较高。
如果对于持久化要求较高，一般会使用 AOF。&lt;/p&gt;

&lt;p&gt;不过使用 AOF 后，正常情况下，总会碰到 &lt;code&gt;Can’t save in background: fork: Cannot allocate memory&lt;/code&gt; 这样的错误。&lt;/p&gt;

&lt;p&gt;这个错误会出现的原因如下：&lt;/p&gt;

&lt;p&gt;Redis 的后台持久化基于操作系统 &lt;code&gt;fork&lt;/code&gt; 的 &lt;code&gt;copy-on-write&lt;/code&gt;特性。redis 会 fork 一个子进程，这个子进程是
父进程的完整拷贝。然后这...&lt;/p&gt;</summary>
    <content type="html">&lt;h2&gt;问题&lt;/h2&gt;

&lt;p&gt;默认情况下，redis 的持久化方案是 RDB，对于数据丢失的风险相对较高。
如果对于持久化要求较高，一般会使用 AOF。&lt;/p&gt;

&lt;p&gt;不过使用 AOF 后，正常情况下，总会碰到 &lt;code&gt;Can’t save in background: fork: Cannot allocate memory&lt;/code&gt; 这样的错误。&lt;/p&gt;

&lt;p&gt;这个错误会出现的原因如下：&lt;/p&gt;

&lt;p&gt;Redis 的后台持久化基于操作系统 &lt;code&gt;fork&lt;/code&gt; 的 &lt;code&gt;copy-on-write&lt;/code&gt;特性。redis 会 fork 一个子进程，这个子进程是
父进程的完整拷贝。然后这个子进程将数据库中的数据报存到磁盘上，完成后销毁。所以，理论上子进程需要消耗和父进程同样多的内存。
然而，由于 &lt;code&gt;copy-on-write&lt;/code&gt;，父子进程其实会共享内存区块。只有父进程中发生了变化的内存区块才会被真正拷贝。
由于理论上，所有的内存区块的数据都是有可能变化的，所以 Linux 并不能事先知道子进程到底真正要消耗多少内存。
所以如果 Linux 的内核参数 &lt;code&gt;overcommit_memory&lt;/code&gt; 设置成 &lt;code&gt;0&lt;/code&gt; 的话，除非空闲内存比父进程占用的内存还要多，
否则 &lt;code&gt;fork&lt;/code&gt; 就会失败。只有当 &lt;code&gt;overcommit_memory&lt;/code&gt; 被设置成 &lt;code&gt;1&lt;/code&gt;，Linux 才会尝试去 &lt;code&gt;fork&lt;/code&gt;。&lt;/p&gt;

&lt;h2&gt;方案&lt;/h2&gt;

&lt;p&gt;思路：将 &lt;code&gt;overcommit_memory&lt;/code&gt; 设置成 &lt;code&gt;1&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;方法 1&lt;/h4&gt;
&lt;pre&gt;&lt;code class="highlight plaintext"&gt;echo 1 &amp;gt; /proc/sys/vm/overcommit_memory
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;方法 2&lt;/h4&gt;
&lt;pre&gt;&lt;code class="highlight plaintext"&gt;sysctl vm.overcommit_memory=1
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;方法 3&lt;/h4&gt;
&lt;pre&gt;&lt;code class="highlight plaintext"&gt;echo 'vm.overcommit_memory=1' &amp;gt; /etc/sysctl.d/60-vm-memory.conf
service procps start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 60开头的文件中的设置会最晚被执行&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Shell 常用快捷键</title>
    <link rel="alternate" href="/2015/03/10/Shell常用快捷键.html"/>
    <id>/2015/03/10/Shell常用快捷键.html</id>
    <published>2015-03-09T16:00:00+00:00</published>
    <updated>2015-03-09T16:00:00+00:00</updated>
    <author>
      <name>Michael Ding</name>
    </author>
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Ctrl + a ：移到命令行首&lt;/li&gt;
&lt;li&gt;Ctrl + e ：移到命令行尾&lt;/li&gt;
&lt;li&gt;Ctrl + f ：-&amp;gt; (向右)&lt;/li&gt;
&lt;li&gt;Ctrl + b ：&amp;lt;- (向左)&lt;/li&gt;
&lt;li&gt;Ctrl + w ：从光标处删除至字首(删除一个单词)&lt;/li&gt;
&lt;li&gt;Ctrl + p：历史中的上一条命令 (向上)&lt;/li&gt;
&lt;li&gt;Ctrl + n：历史中的下一条命令 (向下)&lt;/li&gt;
&lt;li&gt;Ctrl + r：搜索命令历史 (重复按键以切换不同的搜索结果)&lt;/li&gt;
&lt;/ul&gt;
</summary>
    <content type="html">&lt;ul&gt;
&lt;li&gt;Ctrl + a ：移到命令行首&lt;/li&gt;
&lt;li&gt;Ctrl + e ：移到命令行尾&lt;/li&gt;
&lt;li&gt;Ctrl + f ：-&amp;gt; (向右)&lt;/li&gt;
&lt;li&gt;Ctrl + b ：&amp;lt;- (向左)&lt;/li&gt;
&lt;li&gt;Ctrl + w ：从光标处删除至字首(删除一个单词)&lt;/li&gt;
&lt;li&gt;Ctrl + p：历史中的上一条命令 (向上)&lt;/li&gt;
&lt;li&gt;Ctrl + n：历史中的下一条命令 (向下)&lt;/li&gt;
&lt;li&gt;Ctrl + r：搜索命令历史 (重复按键以切换不同的搜索结果)&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
</feed>
